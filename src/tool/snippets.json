{
    "context.context_app": {
        "prefix": "context.context_app",
        "description": "The application context of the current action",
        "body": "context.context_app"
    },
    "context.context_screen": {
        "prefix": "context.context_screen",
        "description": "The screen context of the current action (the current screen)",
        "body": "context.context_screen"
    },
    "context.context_layer": {
        "prefix": "context.context_layer",
        "description": "The layer context of the current action (the current layer)",
        "body": "context.context_layer"
    },
    "context.context_control": {
        "prefix": "context.context_control",
        "description": "The control context of the current action (the current control)",
        "body": "context.context_control"
    },
    "context.context_group": {
        "prefix": "context.context_group",
        "description": "The group context of the current action (the current group)",
        "body": "context.context_group"
    },
    "context.context_row": {
        "prefix": "context.context_row",
        "description": "If the context_control is a Table then this is the row index of the current cell",
        "body": "context.context_row"
    },
    "context.context_col": {
        "prefix": "context.context_col",
        "description": "If the context_control is a Table then this is the column index of the current cell",
        "body": "context.context_col"
    },
    "context.active_context": {
        "prefix": "context.active_context",
        "description": "The fully qualified name of the model object that invoked the action. If that object is the application, this will be the empty string.",
        "body": "context.active_context"
    },
    "context.context_event": {
        "prefix": "context.context_event",
        "description": "The name of the event that triggered the action",
        "body": "context.context_event"
    },
    "context.context_event_data": {
        "prefix": "context.context_event_data",
        "description": "",
        "body": "context.context_event_data"
    },
    "animationstate.state": {
        "prefix": "animationstate.state",
        "description": "either gre.ANIMATION_NOT_FOUND, gre.ANIMATION_NOT_RUNNING, gre.ANIMATION_PAUSED, gre.ANIMATION_RUNNING, gre.ANIMATION_COMPLETE",
        "body": "animationstate.state"
    },
    "animationstate.progress": {
        "prefix": "animationstate.progress",
        "description": "a number between 0 and 1",
        "body": "animationstate.progress"
    },
    "animationstate.reverse": {
        "prefix": "animationstate.reverse",
        "description": "",
        "body": "animationstate.reverse"
    },
    "animationstate.duration": {
        "prefix": "animationstate.duration",
        "description": "",
        "body": "animationstate.duration"
    },
    "animationdata.id": {
        "prefix": "animationdata.id",
        "description": "an override id used to identify the running animation which by default is the original animation name or id returned from gre.animation_create. (default nil)",
        "body": "animationdata.id"
    },
    "animationdata.context": {
        "prefix": "animationdata.context",
        "description": "the context that will be used by the animation to resolve it's varables. (default nil)",
        "body": "animationdata.context"
    },
    "animationdata.progress": {
        "prefix": "animationdata.progress",
        "description": "a number from 0-1 which corresponds to the animation's progress (default 0)",
        "body": "animationdata.progress"
    },
    "animationdata.pause": {
        "prefix": "animationdata.pause",
        "description": "when true, the animation will begin in a paused state.  Can be used in combination with the progress option to provide a seeking functionality. (default false)",
        "body": "animationdata.pause"
    },
    "animationdata.reverse": {
        "prefix": "animationdata.reverse",
        "description": "a boolean to indicate if the animation should run in reverse (default false)",
        "body": "animationdata.reverse"
    },
    "animationdata.cleanup": {
        "prefix": "animationdata.cleanup",
        "description": "",
        "body": "animationdata.cleanup"
    },
    "controlattrs.x": {
        "prefix": "controlattrs.x",
        "description": "",
        "body": "controlattrs.x"
    },
    "controlattrs.y": {
        "prefix": "controlattrs.y",
        "description": "",
        "body": "controlattrs.y"
    },
    "controlattrs.width": {
        "prefix": "controlattrs.width",
        "description": "",
        "body": "controlattrs.width"
    },
    "controlattrs.height": {
        "prefix": "controlattrs.height",
        "description": "",
        "body": "controlattrs.height"
    },
    "controlattrs.hidden": {
        "prefix": "controlattrs.hidden",
        "description": "",
        "body": "controlattrs.hidden"
    },
    "controlattrs.active": {
        "prefix": "controlattrs.active",
        "description": "",
        "body": "controlattrs.active"
    },
    "controlattrs.findex": {
        "prefix": "controlattrs.findex",
        "description": "",
        "body": "controlattrs.findex"
    },
    "controlattrs.mask_enabled": {
        "prefix": "controlattrs.mask_enabled",
        "description": "",
        "body": "controlattrs.mask_enabled"
    },
    "tableattrs.rows": {
        "prefix": "tableattrs.rows",
        "description": "@extends #controlattrs",
        "body": "tableattrs.rows"
    },
    "tableattrs.cols": {
        "prefix": "tableattrs.cols",
        "description": "",
        "body": "tableattrs.cols"
    },
    "tableattrs.visible_rows": {
        "prefix": "tableattrs.visible_rows",
        "description": "",
        "body": "tableattrs.visible_rows"
    },
    "tableattrs.visible_cols": {
        "prefix": "tableattrs.visible_cols",
        "description": "",
        "body": "tableattrs.visible_cols"
    },
    "tableattrs.active_row": {
        "prefix": "tableattrs.active_row",
        "description": "",
        "body": "tableattrs.active_row"
    },
    "tableattrs.active_col": {
        "prefix": "tableattrs.active_col",
        "description": "",
        "body": "tableattrs.active_col"
    },
    "tableattrs.row": {
        "prefix": "tableattrs.row",
        "description": "",
        "body": "tableattrs.row"
    },
    "tableattrs.col": {
        "prefix": "tableattrs.col",
        "description": "",
        "body": "tableattrs.col"
    },
    "tablecellattrs.x": {
        "prefix": "tablecellattrs.x",
        "description": "",
        "body": "tablecellattrs.x"
    },
    "tablecellattrs.y": {
        "prefix": "tablecellattrs.y",
        "description": "",
        "body": "tablecellattrs.y"
    },
    "tablecellattrs.width": {
        "prefix": "tablecellattrs.width",
        "description": "",
        "body": "tablecellattrs.width"
    },
    "tablecellattrs.height": {
        "prefix": "tablecellattrs.height",
        "description": "",
        "body": "tablecellattrs.height"
    },
    "tablecellattrs.hidden": {
        "prefix": "tablecellattrs.hidden",
        "description": "",
        "body": "tablecellattrs.hidden"
    },
    "groupattrs.x": {
        "prefix": "groupattrs.x",
        "description": "",
        "body": "groupattrs.x"
    },
    "groupattrs.y": {
        "prefix": "groupattrs.y",
        "description": "",
        "body": "groupattrs.y"
    },
    "groupattrs.width": {
        "prefix": "groupattrs.width",
        "description": "",
        "body": "groupattrs.width"
    },
    "groupattrs.height": {
        "prefix": "groupattrs.height",
        "description": "",
        "body": "groupattrs.height"
    },
    "groupattrs.abs_x": {
        "prefix": "groupattrs.abs_x",
        "description": "",
        "body": "groupattrs.abs_x"
    },
    "groupattrs.abs_y": {
        "prefix": "groupattrs.abs_y",
        "description": "",
        "body": "groupattrs.abs_y"
    },
    "groupattrs.abs_width": {
        "prefix": "groupattrs.abs_width",
        "description": "",
        "body": "groupattrs.abs_width"
    },
    "groupattrs.abs_height": {
        "prefix": "groupattrs.abs_height",
        "description": "",
        "body": "groupattrs.abs_height"
    },
    "groupattrs.hidden": {
        "prefix": "groupattrs.hidden",
        "description": "",
        "body": "groupattrs.hidden"
    },
    "layerattrs.x": {
        "prefix": "layerattrs.x",
        "description": "",
        "body": "layerattrs.x"
    },
    "layerattrs.y": {
        "prefix": "layerattrs.y",
        "description": "",
        "body": "layerattrs.y"
    },
    "layerattrs.width": {
        "prefix": "layerattrs.width",
        "description": "",
        "body": "layerattrs.width"
    },
    "layerattrs.height": {
        "prefix": "layerattrs.height",
        "description": "",
        "body": "layerattrs.height"
    },
    "layerattrs.xoffset": {
        "prefix": "layerattrs.xoffset",
        "description": "",
        "body": "layerattrs.xoffset"
    },
    "layerattrs.yoffset": {
        "prefix": "layerattrs.yoffset",
        "description": "",
        "body": "layerattrs.yoffset"
    },
    "layerattrs.hidden": {
        "prefix": "layerattrs.hidden",
        "description": "",
        "body": "layerattrs.hidden"
    },
    "layerattrs.geometry": {
        "prefix": "layerattrs.geometry",
        "description": "",
        "body": "layerattrs.geometry"
    },
    "layerattrs.effect": {
        "prefix": "layerattrs.effect",
        "description": "",
        "body": "layerattrs.effect"
    },
    "canvas.get_dimensions": {
        "prefix": "canvas.get_dimensions",
        "description": "@param self\n@returns #table size A table containing width and height",
        "body": "canvas.get_dimensions(${1:self})"
    },
    "canvas.fill": {
        "prefix": "canvas.fill",
        "description": "@param self\n@param #number color An RGB color value as an integer value",
        "body": "canvas.fill(${1:self}, ${2:color})"
    },
    "canvas.fill_rect": {
        "prefix": "canvas.fill_rect",
        "description": "@param self\n@param #number x1 The x position of the first corner\n@param #number y1 The y position of the first corner\n@param #number x2 The x position of the second corner\n@param #number y2 The y position of the second corner\n@param #number color An RGB color value as an integer value",
        "body": "canvas.fill_rect(${1:self}, ${2:x1}, ${3:y1}, ${4:x2}, ${5:y2}, ${6:color})"
    },
    "canvas.fill_poly": {
        "prefix": "canvas.fill_poly",
        "description": "@param self\n@param #table xytable A Lua table {{x=x1,y=y1},{x=x2,y=y2}...}.  Alternatively two tables of parameters containing an\narray of points may be provided as in {x1,x2,..}, {y1,y2,..} similar to using gre.poly_string\n@param #number color An RGB color value as an integer value",
        "body": "canvas.fill_poly(${1:self}, ${2:xytable}, ${3:color})"
    },
    "canvas.fill_circle": {
        "prefix": "canvas.fill_circle",
        "description": "@param self\n@param #number x The x position of the center of the circle\n@param #number y The y position of the center of the circle\n@param #number radius The radius of the circle\n@param #number color An RGB color value as an integer value",
        "body": "canvas.fill_circle(${1:self}, ${2:x}, ${3:y}, ${4:radius}, ${5:color})"
    },
    "canvas.fill_ellipse": {
        "prefix": "canvas.fill_ellipse",
        "description": "@param self\n@param #number x The x position of the center of the ellipse\n@param #number y The y position of the center of the ellipse\n@param #number radius_x The radius in the x direction of the ellipse\n@param #number radius_y The radius in the y direction of the ellipse\n@param #number rotation The rotation angle in degrees clockwise\n@param #number color An RGB color value as an integer value",
        "body": "canvas.fill_ellipse(${1:self}, ${2:x}, ${3:y}, ${4:radius_x}, ${5:radius_y}, ${6:rotation}, ${7:color})"
    },
    "canvas.fill_arc": {
        "prefix": "canvas.fill_arc",
        "description": "@param self\n@param #number x The x position of the center of the arc\n@param #number y The y position of the center of the arc\n@param #number radius_x The radius in the x direction of the arc\n@param #number radius_y The radius in the y direction of the arc\n@param #number start The start angle of the arc in degrees clockwise from the positive x axis\n@param #number end The end angle of the arc in degrees clockwise from the positive x axis\n@param #number rotation The rotation angle in degrees clockwise\n@param #number color An RGB color value as an integer value",
        "body": "canvas.fill_arc(${1:self}, ${2:x}, ${3:y}, ${4:radius_x}, ${5:radius_y}, ${6:start}, ${7:end}, ${8:rotation}, ${9:color})"
    },
    "canvas.stroke_circle": {
        "prefix": "canvas.stroke_circle",
        "description": "@param self\n@param #number x The x position of the center of the circle\n@param #number y The y position of the center of the circle\n@param #number radius The radius of the circle\n@param #number color An RGB color value as an integer value",
        "body": "canvas.stroke_circle(${1:self}, ${2:x}, ${3:y}, ${4:radius}, ${5:color})"
    },
    "canvas.stroke_ellipse": {
        "prefix": "canvas.stroke_ellipse",
        "description": "@param self\n@param #number x The x position of the center of the ellipse\n@param #number y The y position of the center of the ellipse\n@param #number radius_x The radius in the x direction of the ellipse\n@param #number radius_y The radius in the y direction of the ellipse\n@param #number rotation The rotation angle in degrees clockwise\n@param #number color An RGB color value as an integer value",
        "body": "canvas.stroke_ellipse(${1:self}, ${2:x}, ${3:y}, ${4:radius_x}, ${5:radius_y}, ${6:rotation}, ${7:color})"
    },
    "canvas.stroke_arc": {
        "prefix": "canvas.stroke_arc",
        "description": "@param self\n@param #number x The x position of the center of the arc\n@param #number y The y position of the center of the arc\n@param #number radius_x The radius in the x direction of the arc\n@param #number radius_y The radius in the y direction of the arc\n@param #number start The start angle of the arc in degrees clockwise from the positive x axis\n@param #number end The end angle of the arc in degrees clockwise from the positive x axis\n@param #number rotation The rotation angle in degrees clockwise\n@param #number color An RGB color value as an integer value",
        "body": "canvas.stroke_arc(${1:self}, ${2:x}, ${3:y}, ${4:radius_x}, ${5:radius_y}, ${6:start}, ${7:end}, ${8:rotation}, ${9:color})"
    },
    "canvas.stroke_line": {
        "prefix": "canvas.stroke_line",
        "description": "@param self\n@param #number x1 The x position of the first corner\n@param #number y1 The y position of the first corner\n@param #number x2 The x position of the second corner\n@param #number y2 The y position of the second corner\n@param #number color An RGB color value as an integer value",
        "body": "canvas.stroke_line(${1:self}, ${2:x1}, ${3:y1}, ${4:x2}, ${5:y2}, ${6:color})"
    },
    "canvas.stroke_rect": {
        "prefix": "canvas.stroke_rect",
        "description": "@param self\n@param #number x1 The x position of the first corner\n@param #number y1 The y position of the first corner\n@param #number x2 The x position of the second corner\n@param #number y2 The y position of the second corner\n@param #number color An RGB color value as an integer value",
        "body": "canvas.stroke_rect(${1:self}, ${2:x1}, ${3:y1}, ${4:x2}, ${5:y2}, ${6:color})"
    },
    "canvas.stroke_poly": {
        "prefix": "canvas.stroke_poly",
        "description": "@param self\n@param #table xytable A Lua table {{x=x1,y=y1},{x=x2,y=y2}...}.  Alternatively two tables of parameters containing an\narray of points may be provided as in {x1,x2,..}, {y1,y2,..} similar to using gre.poly_string\n@param #number color An RGB color value as an integer value",
        "body": "canvas.stroke_poly(${1:self}, ${2:xytable}, ${3:color})"
    },
    "canvas.clear_rect": {
        "prefix": "canvas.clear_rect",
        "description": "@param self\n@param #number x1 The x position of the first corner\n@param #number y1 The y position of the first corner\n@param #number x2 The x position of the second corner\n@param #number y2 The y position of the second corner",
        "body": "canvas.clear_rect(${1:self}, ${2:x1}, ${3:y1}, ${4:x2}, ${5:y2})"
    },
    "canvas.set_pixel": {
        "prefix": "canvas.set_pixel",
        "description": "@param self\n@param #number x The x position of the pixel\n@param #number y The y position of the pixel\n@param #number color An RGB color value as an integer value",
        "body": "canvas.set_pixel(${1:self}, ${2:x}, ${3:y}, ${4:color})"
    },
    "canvas.set_alpha": {
        "prefix": "canvas.set_alpha",
        "description": "@param self\n@param #number alpha An integer value for alpha from 0-255, values outside this range will be clamped",
        "body": "canvas.set_alpha(${1:self}, ${2:alpha})"
    },
    "canvas.set_line_width": {
        "prefix": "canvas.set_line_width",
        "description": "@param self\n@param #number linewidth An integer value greater than 1 indicating the pixel width.",
        "body": "canvas.set_line_width(${1:self}, ${2:linewidth})"
    },
    "canvas.draw_image": {
        "prefix": "canvas.draw_image",
        "description": "@param self\n@param #string name The project relative name of the image\n@param #table attrs A table containing optional keys x(default: 0), y(default: 0), w(default: natural height), h(default: natural height), rotation(default: 0), valign(default: gre.TOP), halign(default: gre.LEFT)",
        "body": "canvas.draw_image(${1:self}, ${2:name}, ${3:attrs})"
    },
    "canvas.get_image_info": {
        "prefix": "canvas.get_image_info",
        "description": "@param self\n@param #string name The project relative name of the image\n@return A table containing the width and height keys",
        "body": "canvas.get_image_info(${1:self}, ${2:name})"
    },
    "canvas.draw_text": {
        "prefix": "canvas.draw_text",
        "description": "@param self\n@param #string The text string to display\n@param #table attrs A table containing font and optional keys x(default: 0), y(default: 0), size(default: 18), color(default: 0x000000), rotation(default: 0)",
        "body": "canvas.draw_text(${1:self}, ${2:The}, ${3:attrs})"
    },
    "gre.set_data": {
        "prefix": "gre.set_data",
        "description": "@param #table data A table containing the variables to change and their new values",
        "body": "gre.set_data(${1:data})"
    },
    "gre.get_data": {
        "prefix": "gre.get_data",
        "description": "@param #string val1\n@param ... Data manager variables to lookup or a table of variables\n@return #table A table containing the passed in arguments as keys and the resulting data manager values as the values associated with those keys",
        "body": "gre.get_data(${1:val1}, ${2:...})"
    },
    "gre.set_value": {
        "prefix": "gre.set_value",
        "description": "@param #string key A string value containing the key to be set with the following value\n@param value The value to be assigned to the preceding key\n@param ... key/value pairs to lookup",
        "body": "gre.set_value(${1:key}, ${2:value}, ${3:...})"
    },
    "gre.get_value": {
        "prefix": "gre.get_value",
        "description": "@param #string key The key whose value should be extracted from the data manager\n@return The value associated with the data manager entry for the key, or nil if no entry exists. If multiple keys are specified, then multiple return values will be generated matching the argument order",
        "body": "gre.get_value(${1:key})"
    },
    "gre.resolve_data_key": {
        "prefix": "gre.resolve_data_key",
        "description": "@param #string key\n@param #string ... One or more string arguments containing the variable to resolve.\n@return #table A table containing the arguments provided on input as keys with the values being the resolved data value",
        "body": "gre.resolve_data_key(${1:key}, ${2:...})"
    },
    "gre.get_control_attrs": {
        "prefix": "gre.get_control_attrs",
        "description": "@param #string control_name The fully qualified name of the control to get information about\n@param #string tags One or more tags as strings\n@return #controlattrs tag_table A table containing the tags as keys with the associated table value being the Storyboard value associated with that tag",
        "body": "gre.get_control_attrs(${1:control_name}, ${2:tags})"
    },
    "gre.set_control_attrs": {
        "prefix": "gre.set_control_attrs",
        "description": "@param #string control_name The fully qualified name of the control to change attributes on\n@param #controlattrs tag_table A table with tags as the keys and the new values stored as the table's key values",
        "body": "gre.set_control_attrs(${1:control_name}, ${2:tag_table})"
    },
    "gre.get_table_attrs": {
        "prefix": "gre.get_table_attrs",
        "description": "@param #string table_name The fully qualified name of the table to get information about\n@param #string tags One or more tags as strings\n@return #tableattrs tag_table A table containing the tags as keys with the associated table value being the Storyboard value associated with that tag",
        "body": "gre.get_table_attrs(${1:table_name}, ${2:tags})"
    },
    "gre.set_table_attrs": {
        "prefix": "gre.set_table_attrs",
        "description": "@param #string table_name The fully qualified name of the table to change attributes on\n@param #tableattrs tag_table A table with tags as the keys and the new values stored as the table's key values",
        "body": "gre.set_table_attrs(${1:table_name}, ${2:tag_table})"
    },
    "gre.get_table_cell_attrs": {
        "prefix": "gre.get_table_cell_attrs",
        "description": "@param #string table_name\n@param #number row\n@param #number col\n@param #string tags\n@return #tablecellattrs A table containing the tags as keys with the associated table value being the Storyboard value associated with that tag",
        "body": "gre.get_table_cell_attrs(${1:table_name}, ${2:row}, ${3:col}, ${4:tags})"
    },
    "gre.set_table_cell_attrs": {
        "prefix": "gre.set_table_cell_attrs",
        "description": "@param #string table_name\n@param #number row\n@param #number col\n@param #string tag_table A table with the tags as keys and the new values stored as the table's key values",
        "body": "gre.set_table_cell_attrs(${1:table_name}, ${2:row}, ${3:col}, ${4:tag_table})"
    },
    "gre.set_table_template_attrs": {
        "prefix": "gre.set_table_template_attrs",
        "description": "@param #string table_name\n@param #number row\n@param #number col\n@param #string tag_table A table with the tags as keys and the new values stored as the table's key values",
        "body": "gre.set_table_template_attrs(${1:table_name}, ${2:row}, ${3:col}, ${4:tag_table})"
    },
    "gre.get_group_attrs": {
        "prefix": "gre.get_group_attrs",
        "description": "@param #string group_name The fully qualified name of the group to get information about\n@param #string tags One or more tags as strings\n@return #groupattrs A table containing the tags as keys with the associated table value being the Storyboard value associated with that tag",
        "body": "gre.get_group_attrs(${1:group_name}, ${2:tags})"
    },
    "gre.set_group_attrs": {
        "prefix": "gre.set_group_attrs",
        "description": "@param #string group_name The fully qualified name of the group to change attributes on\n@param #groupattrs tag_table A table with tags as the keys and the new values stored as the table's key values",
        "body": "gre.set_group_attrs(${1:group_name}, ${2:tag_table})"
    },
    "gre.get_layer_attrs": {
        "prefix": "gre.get_layer_attrs",
        "description": "@param #string layer_name The fully qualified name of the layer to get information about\n@param #string tags One or more tags as strings\n@return #layerattrs tag_table A table containing the tags as keys with the associated table value being the Storyboard value associated with that tag",
        "body": "gre.get_layer_attrs(${1:layer_name}, ${2:tags})"
    },
    "gre.set_layer_attrs": {
        "prefix": "gre.set_layer_attrs",
        "description": "@param layer_name The fully qualified name of the layer to change attributes on\n@param #layerattrs tag_table A table with tags as the keys and the new values stored as the table's key values",
        "body": "gre.set_layer_attrs(${1:layer_name}, ${2:tag_table})"
    },
    "gre.set_layer_attrs_global": {
        "prefix": "gre.set_layer_attrs_global",
        "description": "@param #string layer_name The fully qualified name of the layer to change attributes on\n@param #layerattrs tag_table A table with tags as the keys and the new values stored as the table's key values",
        "body": "gre.set_layer_attrs_global(${1:layer_name}, ${2:tag_table})"
    },
    "gre.move_control": {
        "prefix": "gre.move_control",
        "description": "@param #string control_name The fully qualified name of the control to move\n@param #number dx A delta from the current x position\n@param #number dy A delta from the current y position\n@param #number x The x position to move to in absolute co-ordinates (Optional).\n@param #number y The y position to move to in absolute co-ordinates (Optional)\n@param #number anchorH Horizontal anchor: gre.LEFT, gre.CENTER, gre.RIGHT (Optional, default is gre.LEFT)\n@param #number anchorV Vertical anchor: gre.TOP, gre.CENTER, gre.BOTTOM (Optional, default is gre.TOP)",
        "body": "gre.move_control(${1:control_name}, ${2:dx}, ${3:dy}, ${4:x}, ${5:y}, ${6:anchorH}, ${7:anchorV})"
    },
    "gre.resize_control": {
        "prefix": "gre.resize_control",
        "description": "@param #string control_name The fully qualified name of the control to move\n@param #number dw A delta from the current width\n@param #number dh A delta from the current height\n@param #number w The new width of the control\n@param #number h The new width of the control\n@param #number anchorH Horizontal anchor: gre.LEFT, gre.CENTER, gre.RIGHT (Optional, default is gre.LEFT)\n@param #number anchorV Vertical anchor: gre.TOP, gre.CENTER, gre.BOTTOM (Optional, default is gre.TOP)",
        "body": "gre.resize_control(${1:control_name}, ${2:dw}, ${3:dh}, ${4:w}, ${5:h}, ${6:anchorH}, ${7:anchorV})"
    },
    "gre.move_layer": {
        "prefix": "gre.move_layer",
        "description": "@param #string layer_name The fully qualified name of the layer to move\n@param #number dx A delta from the current x position\n@param #number dy A delta from the current y position\n@param #number x The x position to move to in absolute co-ordinates\n@param #number y The y position to move to in absolute co-ordinates",
        "body": "gre.move_layer(${1:layer_name}, ${2:dx}, ${3:dy}, ${4:x}, ${5:y})"
    },
    "gre.set_focus": {
        "prefix": "gre.set_focus",
        "description": "@param #string fqn The fully qualified name of the control to receive focus\n@return #boolean true for success, false for failure or nil if an error occurs during processing",
        "body": "gre.set_focus(${1:fqn})"
    },
    "gre.get_focus": {
        "prefix": "gre.get_focus",
        "description": "return #string The fully qualified name of the control with focus or nil if no control is focused",
        "body": "gre.get_focus()"
    },
    "gre.send_event": {
        "prefix": "gre.send_event",
        "description": "@param #string event A string containing the event to send or a table containing the following fields: name, target(optional), format(optional), data(optional)\n@param #string channel An optional Storyboard IO channel to send the event on\nreturn #boolean true for success, false for failure and error message string, e.g. \"Can't open greio channel my_channel\"",
        "body": "gre.send_event(${1:event}, ${2:channel})"
    },
    "gre.send_event_target": {
        "prefix": "gre.send_event_target",
        "description": "@param #string event_name A string containing the event to send\n@param #string target A string containing the object to target the event to\n@param #string channel An optional Storyboard IO channel to send the event on\nreturn #boolean true for success, false for failure and error message string, e.g. \"Can't open greio channel my_channel\"",
        "body": "gre.send_event_target(${1:event_name}, ${2:target}, ${3:channel})"
    },
    "gre.send_event_data": {
        "prefix": "gre.send_event_data",
        "description": "@param #string event_name A string containing the event to send\n@param #string format_string A string format of the event data payload\n@param #table data A table whose keys match up with the keys specified in the format_string\n@param #string channel An optional Storyboard IO channel to send the event on\nreturn #boolean true for success, false for failure and error message string, e.g. \"Can't open greio channel my_channel\"",
        "body": "gre.send_event_data(${1:event_name}, ${2:format_string}, ${3:data}, ${4:channel})"
    },
    "gre.add_event_listener": {
        "prefix": "gre.add_event_listener",
        "description": "@param #string event The name of the event to listen for\n@param #string target The fully qualified name of the model object to listen on, or the empty string to listen on the application\n@param #function callback A callback to invoke when the event is triggered, it receives the same mapargs table as a standard lua callback\nreturn #number An integer that identifies the newly created listener, or nil on failure",
        "body": "gre.add_event_listener(${1:event}, ${2:target}, ${3:callback})"
    },
    "gre.remove_event_listener": {
        "prefix": "gre.remove_event_listener",
        "description": "@param #number id The identifier of the listener to remove (returned from gre.add_event_listener)",
        "body": "gre.remove_event_listener(${1:id})"
    },
    "gre.greio_disconnect": {
        "prefix": "gre.greio_disconnect",
        "description": "@param #string channel The channel to be disconnected\n@param #boolean is_receiving An option boolean parameter. True if closing a receiving channel, false or no argument if closing a sending channel",
        "body": "gre.greio_disconnect(${1:channel}, ${2:is_receiving})"
    },
    "gre.clone_object": {
        "prefix": "gre.clone_object",
        "description": "@param #string reference_object_name The name of the control or group to clone\n@param #string new_object_name The name for the new object, must be unique within the parent\n@param #string parent_name The name of the layer or group to place this object on, must already exist\n@param #table data An optional table with tags as keys and their new values as the values of the table",
        "body": "gre.clone_object(${1:reference_object_name}, ${2:new_object_name}, ${3:parent_name}, ${4:data})"
    },
    "gre.delete_object": {
        "prefix": "gre.delete_object",
        "description": "@param #string object_name The name of the object to delete",
        "body": "gre.delete_object(${1:object_name})"
    },
    "gre.clone_control": {
        "prefix": "gre.clone_control",
        "description": "@param #string template_name The name of the control to clone\n@param #string new_control_name The name for the new control, must be unique\n@param #string layer_name The name of the layer to place this control on, must already exist\n@param #table data An optional table with tags as keys and their new values as the values of the table",
        "body": "gre.clone_control(${1:template_name}, ${2:new_control_name}, ${3:layer_name}, ${4:data})"
    },
    "gre.delete_control": {
        "prefix": "gre.delete_control",
        "description": "@param #string control_name The name of the control to delete",
        "body": "gre.delete_control(${1:control_name})"
    },
    "gre.poly_string": {
        "prefix": "gre.poly_string",
        "description": "@param #list<#number> x_values\n@param #list<#number> y_values",
        "body": "gre.poly_string(${1:x_values}, ${2:y_values})"
    },
    "gre.get_string_size": {
        "prefix": "gre.get_string_size",
        "description": "@param #string font\n@param #number font_size\n@param #string text\n@param #number width\n@param #table data\n@return #table A table containing the following values. width, the width of the widest rendered line. height, total height of rendered string. n\\_lines, number of lines text occupies when rendered.",
        "body": "gre.get_string_size(${1:font}, ${2:font_size}, ${3:text}, ${4:width}, ${5:data})"
    },
    "gre.load_resource": {
        "prefix": "gre.load_resource",
        "description": "@param #string pool_name The name of the resource pool: image or font\n@param #string resource_name The name of the resource that is to be loaded\n@param #table pool_parameters Optional parameter that can vary depending on the pool being specified.",
        "body": "gre.load_resource(${1:pool_name}, ${2:resource_name}, ${3:pool_parameters})"
    },
    "gre.dump_resource": {
        "prefix": "gre.dump_resource",
        "description": "@param #string pool_name The name of the resource pool: image or font\n@param #string resource_name The name of the resource that is to be removed",
        "body": "gre.dump_resource(${1:pool_name}, ${2:resource_name})"
    },
    "gre.walk_pool": {
        "prefix": "gre.walk_pool",
        "description": "@param #string pool_name The resource pool whose content should be reported\n@return #table A table is returned with keys as the resources that are contained in the pool and values indicating the number of bytes that a particular resource is using within the system",
        "body": "gre.walk_pool(${1:pool_name})"
    },
    "gre.load_image": {
        "prefix": "gre.load_image",
        "description": "@param #string image_name The name of the resource that is to be loaded\n@param #table parameters An optional table with the following keys: w (width), h (height), background (Whether or not to load the image asynchronously as the 'background')",
        "body": "gre.load_image(${1:image_name}, ${2:parameters})"
    },
    "gre.timer_set_timeout": {
        "prefix": "gre.timer_set_timeout",
        "description": "@param #number timeout The time in milliseconds before the timer should fire\n@param #function function The function called when the timer fires\n@return A piece of lightuserdata which serves as an identifier for the timer",
        "body": "gre.timer_set_timeout(${1:timeout}, ${2:function})"
    },
    "gre.timer_set_interval": {
        "prefix": "gre.timer_set_interval",
        "description": "@param #number interval The time in milliseconds between firings\n@param #function function The function to be called when the timer fires\n@return A piece of lightuserdata which serves as an identifier for the timer",
        "body": "gre.timer_set_interval(${1:interval}, ${2:function})"
    },
    "gre.timer_clear_timeout": {
        "prefix": "gre.timer_clear_timeout",
        "description": "@param id The lightuserdata representing the timer",
        "body": "gre.timer_clear_timeout(${1:id})"
    },
    "gre.timer_clear_interval": {
        "prefix": "gre.timer_clear_interval",
        "description": "@param id The lightuserdata representing the timer",
        "body": "gre.timer_clear_interval(${1:id})"
    },
    "gre.animation_create": {
        "prefix": "gre.animation_create",
        "description": "@param #number fps The animation framerate\n@param #boolean auto_destroy Optional parameter, (0) preserves the animation, (1) releases the animation once completed\n@param #function end_callback Optional parameter, callback function which is invoked when the animation completes\n@return An animation id to be used on future animation calls, nil on failure",
        "body": "gre.animation_create(${1:fps}, ${2:auto_destroy}, ${3:end_callback})"
    },
    "gre.animation_add_step": {
        "prefix": "gre.animation_add_step",
        "description": "@param id The animation id\n@param #table data A table of animation step values which can include: key, rate, duration, offset, from, to, delta.",
        "body": "gre.animation_add_step(${1:id}, ${2:data})"
    },
    "gre.animation_destroy": {
        "prefix": "gre.animation_destroy",
        "description": "@param id The animation to destroy",
        "body": "gre.animation_destroy(${1:id})"
    },
    "gre.animation_trigger": {
        "prefix": "gre.animation_trigger",
        "description": "@param id The animation to trigger\n@param #animationdata data An optional table with id/context/progress/pause/reverse/cleanup values",
        "body": "gre.animation_trigger(${1:id}, ${2:data})"
    },
    "gre.animation_stop": {
        "prefix": "gre.animation_stop",
        "description": "@param id The animation to trigger\n@param #animationdata data An optional table with id/context values",
        "body": "gre.animation_stop(${1:id}, ${2:data})"
    },
    "gre.animation_pause": {
        "prefix": "gre.animation_pause",
        "description": "@param id The animation to pause\n@param #animationdata data An optional table with id/context values",
        "body": "gre.animation_pause(${1:id}, ${2:data})"
    },
    "gre.animation_resume": {
        "prefix": "gre.animation_resume",
        "description": "@param id The animation to resume\n@param #animationdata data An optional table with id/context values",
        "body": "gre.animation_resume(${1:id}, ${2:data})"
    },
    "gre.animation_get_state": {
        "prefix": "gre.animation_get_state",
        "description": "@param name the animation to retreive state information.\n@return #animationstate table with 'state', 'progress', 'duration' and 'reverse' values",
        "body": "gre.animation_get_state(${1:name})"
    },
    "gre.animation_create_tween": {
        "prefix": "gre.animation_create_tween",
        "description": "@param #string name The name to use for the tween operation, it is case sensitive\nand must not collide with other tween names\n@param #function tween_callback The callback function to be invoked when an animation\nusing the named tween function is invoked\n@return #boolean true on successful registration",
        "body": "gre.animation_create_tween(${1:name}, ${2:tween_callback})"
    },
    "gre.touch": {
        "prefix": "gre.touch",
        "description": "@param #number x The x position to simulate the touch\n@param #number y The y position to simulate the touch\n@param #string channel An optional Storyboard IO channel to send the event on",
        "body": "gre.touch(${1:x}, ${2:y}, ${3:channel})"
    },
    "gre.key_up": {
        "prefix": "gre.key_up",
        "description": "@param #number code The utf-8 character code to inject\n@param #string channel An optional Storyboard IO channel to send the event on",
        "body": "gre.key_up(${1:code}, ${2:channel})"
    },
    "gre.key_down": {
        "prefix": "gre.key_down",
        "description": "@param #number code The utf-8 character code to inject\n@param #string channel An optional Storyboard IO channel to send the event on",
        "body": "gre.key_down(${1:code}, ${2:channel})"
    },
    "gre.key_repeat": {
        "prefix": "gre.key_repeat",
        "description": "@param #number code The utf-8 character code to inject\n@param #string channel An optional Storyboard IO channel to send the event on",
        "body": "gre.key_repeat(${1:code}, ${2:channel})"
    },
    "gre.redraw": {
        "prefix": "gre.redraw",
        "description": "@param #number x The x position of the redraw bounding box\n@param #number y The y position of the redraw bounding box\n@param #number width The width of the redraw bounding box\n@param #number height The height of the redraw bounding box\n@param #string channel An optional Storyboard IO channel to send the event on",
        "body": "gre.redraw(${1:x}, ${2:y}, ${3:width}, ${4:height}, ${5:channel})"
    },
    "gre.quit": {
        "prefix": "gre.quit",
        "description": "@param #string channel An optional Storyboard IO channel to send the event on",
        "body": "gre.quit(${1:channel})"
    },
    "gre.thread_create": {
        "prefix": "gre.thread_create",
        "description": "@param #function The Lua function to run in a separate thread of execution from the main UI thread",
        "body": "gre.thread_create(${1:The})"
    },
    "gre.receive_event": {
        "prefix": "gre.receive_event",
        "description": "@param channel A Storyboard IO channel to receive the event on\n@return #table A table containing the name, target, format and a data table from a received event",
        "body": "gre.receive_event(${1:channel})"
    },
    "gre.env": {
        "prefix": "gre.env",
        "description": "@param key_table A single string or a table of strings to look up.\n@return If a single string is provided as an input argument, just a single data value for that argument is return. If a table is provided as an input argument, then a table with key/value pairs corresponding to the keys of the input argument and the results they provide.",
        "body": "gre.env(${1:key_table})"
    },
    "gre.log": {
        "prefix": "gre.log",
        "description": "@param #number id An integer value that matches the enumeration in gre/gre.h to prefix the log message with a code, or -1 to simply output the message. If a non-negative value is used, then the output will be subjected to the verbosity logging filtering.\n@param #string msg The message to output to the logging system.",
        "body": "gre.log(${1:id}, ${2:msg})"
    },
    "gre.mstime": {
        "prefix": "gre.mstime",
        "description": "@return #number The current time in milliseconds in a system specific manner (gre.mstime()) or the time in milliseconds since the start of the application (gre.mstime(true))",
        "body": "gre.mstime()"
    },
    "gre.ustime": {
        "prefix": "gre.ustime",
        "description": "@return #number The current time in microseconds in a system specific manner (gre.ustime()) or the time in microseconds since the start of the application (gre.ustime(true))",
        "body": "gre.ustime()"
    },
    "gre.rgb": {
        "prefix": "gre.rgb",
        "description": "@param #number r An integer value for red from 0-255\n@param #number g An integer value for green from 0-255\n@param #number b An integer value for blue from 0-255\n@param #number a An optional integer value for alpha from 0-255\n@return #number color An RGB color value as an integer value",
        "body": "gre.rgb(${1:r}, ${2:g}, ${3:b}, ${4:a})"
    },
    "gre.to_rgb": {
        "prefix": "gre.to_rgb",
        "description": "@param #number color A color value\n@return #number red An integer from 0-255\n@return #number green An integer from 0-255\n@return #number blue An integer from 0-255\n@return #number alpha An integer from 0-255",
        "body": "gre.to_rgb(${1:color})"
    },
    "gre.to_alignment": {
        "prefix": "gre.to_alignment",
        "description": "@param #string alignment A string value of \"left\", \"right\", \"center\", \"top\" or \"bottom\"\n@return #number alignment An integer corresponding to gre.LEFT, gre.RIGHT, gre.CENTER, gre.TOP or gre.BOTTOM",
        "body": "gre.to_alignment(${1:alignment})"
    },
    "gre.to_alpha": {
        "prefix": "gre.to_alpha",
        "description": "@param #number percent A number from 1 - 100\n@return #number alpha An integer from 0-255",
        "body": "gre.to_alpha(${1:percent})"
    },
    "gre.rtext_text_extent": {
        "prefix": "gre.rtext_text_extent",
        "description": "@param #string text The rich text string to extent\n@param #string target A string containing the parent control of the rich text rext you are targeting\n@param #table parameters Optional parameters: size, line-height, max-width, regular-font, bold-font, italic-font, italic-bold-font\n@return #table A table containing the keys, width and height",
        "body": "gre.rtext_text_extent(${1:text}, ${2:target}, ${3:parameters})"
    },
    "gre.get_canvas": {
        "prefix": "gre.get_canvas",
        "description": "@param #string Canvas object\n@return #canvas canvas A CANVAS object that represents the canvas or nil if no canvas can be found.",
        "body": "gre.get_canvas(${1:Canvas})"
    }
}